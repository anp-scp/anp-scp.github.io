{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":"<p>Anupam Sharma is a PhD student at department of Computer Science &amp; Engineering at the Indian Institute of Technology, Gandhinagar (IITGN). He previously completed his Bachelors in Technology from Central Institute of Technology Assam and worked as a Project Engineer at the Cyber Defense Center at Wipro Ltd.</p> <p>His research interests include deep learning, representation learning, meta-learning and its application in Brain-Computer Interface (BCI) domain.</p> <p></p> <p> </p> <p></p>"},{"location":"#_2","title":"Home","text":""},{"location":"#research-overview","title":"Research Overview","text":"<p>Here is a short video giving a brief overview of my current research work.</p>"},{"location":"#news","title":"News","text":"Evaluating Fast Adaptability of Neural Networks for Brain-Computer Interface | March 2024 <p>Work with <code>Dr. Krishna Miyapuram</code> | To appear at <code>IJCNN, IEEE World Congress on Computational Intelligence '24</code> | <code>Arxiv</code></p> <p>Electroencephalography (EEG) classification is a versatile and portable technique for building non-invasive Brain-computer Interfaces (BCI). However, the classifiers that decode cognitive states from EEG brain data perform poorly when tested on newer domains, such as tasks or individuals absent during model training. Researchers have recently used complex strategies like Model-agnostic meta-learning (MAML) for domain adaptation. Nevertheless, there is a need for an evaluation strategy to evaluate the fast adaptability of the models, as this characteristic is essential for real-life BCI applications for quick calibration. We used motor movement and imaginary signals as input to Convolutional Neural Networks (CNN) based classifier for the experiments. Datasets with EEG signals typically have fewer examples and higher time resolution. Even though batch-normalization is preferred for Convolutional Neural Networks (CNN), we empirically show that layer-normalization can improve the adaptability of CNN-based EEG classifiers with not more than ten fine-tuning steps. In summary, the present work (i) proposes a simple strategy to evaluate fast adaptability, and (ii) empirically demonstrate fast adaptability across individuals as well as across tasks with simple transfer learning as compared to MAML approach.</p> IIT Gandhinagar Director's PhD Fellowship | Feb 2024 <p>Received The Director's PhD Fellowship at IIT GN. Extremely thankful to all mentors for making this recognition possible.</p> <p>\u201cDirector\u2019s PhD Fellowship\u201d at the Indian Institute of Technology (IIT) Gandhinagar is intended to encourage top-quality IIT Gandhinagar students to join the PhD programme of the Institute right after completing their degree (BTech/MSc/MA/MTech) at the Institute. Having excelled in their academics at IIT Gandhinagar, such students could transition to their PhD programme with ease and complete the PhD work faster than the other students.</p> <p>Joined CSE at <code>IITGN</code> as a M.Tech. Student | July 2022</p> <p>Joined <code>Wipro Ltd</code> as a Project Engineer | Oct 2019</p> <p>All News </p>"},{"location":"news/","title":"News","text":"Evaluating Fast Adaptability of Neural Networks for Brain-Computer Interface | March 2024 <p>Work with <code>Dr. Krishna Miyapuram</code> | To appear at <code>IJCNN, IEEE World Congress on Computational Intelligence '24</code> | <code>Arxiv</code></p> <p>Electroencephalography (EEG) classification is a versatile and portable technique for building non-invasive Brain-computer Interfaces (BCI). However, the classifiers that decode cognitive states from EEG brain data perform poorly when tested on newer domains, such as tasks or individuals absent during model training. Researchers have recently used complex strategies like Model-agnostic meta-learning (MAML) for domain adaptation. Nevertheless, there is a need for an evaluation strategy to evaluate the fast adaptability of the models, as this characteristic is essential for real-life BCI applications for quick calibration. We used motor movement and imaginary signals as input to Convolutional Neural Networks (CNN) based classifier for the experiments. Datasets with EEG signals typically have fewer examples and higher time resolution. Even though batch-normalization is preferred for Convolutional Neural Networks (CNN), we empirically show that layer-normalization can improve the adaptability of CNN-based EEG classifiers with not more than ten fine-tuning steps. In summary, the present work (i) proposes a simple strategy to evaluate fast adaptability, and (ii) empirically demonstrate fast adaptability across individuals as well as across tasks with simple transfer learning as compared to MAML approach.</p> IIT Gandhinagar Director's PhD Fellowship | Feb 2024 <p>Received The Director's PhD Fellowship at IIT GN. Extremely thankful to all mentors for making this recognition possible.</p> <p>\u201cDirector\u2019s PhD Fellowship\u201d at the Indian Institute of Technology (IIT) Gandhinagar is intended to encourage top-quality IIT Gandhinagar students to join the PhD programme of the Institute right after completing their degree (BTech/MSc/MA/MTech) at the Institute. Having excelled in their academics at IIT Gandhinagar, such students could transition to their PhD programme with ease and complete the PhD work faster than the other students.</p> <p>Joined CSE at <code>IITGN</code> as a M.Tech. Student | July 2022</p> <p>Joined <code>Wipro Ltd</code> as a Project Engineer | Oct 2019</p> <p>Completed B.Tech in CSE from <code>Central Institute of Technology Assam</code> | June 2019</p> <p>Received best project award during Summer Training at <code>CETPA Infotech</code> | July 2017</p>"},{"location":"projects/","title":"Projects","text":"<ul> <li> <p>Package Dependency Game</p> <p>An interactive web-based game that simulates the process of resolving package dependencies. Players are presented with a set of packages and their dependencies, and must determine a valid installation order or identify conflicts. The game is designed to help users understand the role of Boolean Propositional Logic in dependency resolution algorithms.</p> <p> About</p> <p> Play</p> </li> <li> <p>Website of Brain Lab</p> <p>Developed the website of Brain Lab, a research lab at IIT Gandhinagar. The website is based on Material for MkDocs and is hosted on GitHub Pages. The website can be easily updated by the lab members via Markdown files. As it is hosted on GitHub Pages, one can send an update via PRs and the website gets updated automatically via GitHub Actions once the PR is merged.  </p> <p> Website</p> </li> <li> <p>Django to REST</p> <p>Django To Rest is small tool that helps to expose REST api(s) for django models with minimum effort. This utility is for one who uses Django REST Framework for writing REST APIs. The tool enables you to focus only on the code needed explicitly. The tool handles all boilerplate for writing CRUD and custom APIs. </p> <p> Website</p> </li> <li> <p>News Aggregator</p> <p>A news aggregator with web crawler, a text classifier, and trending news creation. Text classification is done using Support Vector Machine and Latent Dirichlet allocation. Sentence creation for trending news is done using sentence ranking. The web app also has provision for real users to publish news.</p> </li> </ul>"},{"location":"publications/","title":"Publications","text":"<ul> <li> <p>Anupam Sharma, Sreyashi Karmakar, Gayatri Priyadarsini Kancherla and Abhishek Bichhawat, \"On the Prevalence and Usage of Commit Signing on GitHub: A Longitudinal and Cross-Domain Study,\" 2025 International Conference on Evaluation and Assessment in Software Engineering (EASE)</p> <p>Code Arxiv To appear at EASE '25</p> </li> </ul> <ul> <li> <p>Anupam Sharma and Krishna Miyapuram, \"Evaluating Fast Adaptability of Neural Networks for Brain-Computer Interface,\" 2024 International Joint Conference on Neural Networks (IJCNN)</p> <p>DOI Code BIB (1) Arxiv </p> </li> </ul> <ol> <li> <pre><code>@INPROCEEDINGS{10650562,\nauthor={Sharma, Anupam and Miyapuram, Krishna},\nbooktitle={2024 International Joint Conference on Neural Networks (IJCNN)}, \ntitle={Evaluating Fast Adaptability of Neural Networks for Brain-Computer Interface}, \nyear={2024},\nvolume={},\nnumber={},\npages={1-8},\nkeywords={Training;Adaptation models;Transfer learning;Brain modeling;Motors;Electroencephalography;Brain-computer interfaces;Electroencephalography;Brain-computer Interface;Convolutional Neural Network;Transfer Learning;Meta Learning},\ndoi={10.1109/IJCNN60899.2024.10650562}}\n</code></pre> </li> </ol>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2019/01/01/deep-dive-into-support-vector-machine-octicons-link-external-16/","title":"Deep Dive into Support Vector Machine","text":"<p>A detailed article on Support Vector Machine published in Towards Data Science</p> <p>Redirecting to Towarda Data Science</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/","title":"SATisfying Installs: How Boolean Logic Navigates Software Dependencies","text":"<p>Have you ever worked on a software development project, whether it was a small personal project to learn new skills or a large application running in production? If yes, then you have most likely used a package manager to install libraries or dependencies. </p> <p>In this blog post, we explore how <code>Boolean Propositional Logic</code> can be used for package management within software development.</p> What is a Boolean Propositional Formula? <p>A Boolean Propositional formula consists of variables \\(x_1, \\dots , x_n\\) and can be one of the following:</p> <ol> <li>True</li> <li>False</li> <li>\\(x_i\\) for some \\(i\\)</li> <li>\\(\\neg x_i\\) for some \\(i\\); if \\(x_i = True\\) for some \\(i\\), then \\(\\neg x_i = False\\)</li> <li>\\(F \\lor G\\) where F and G are formulas. This is referred to as <code>OR</code> or disjunction</li> <li>\\(F \\land G\\) where F and G are formulas. This is referred to as <code>AND</code> or conjunction</li> <li>\\(F \\implies G\\) where F and G are formulas. This is referred to as implication, which is equivalent to \\(\\neg F \\lor G\\)</li> </ol>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#what-is-a-package-manager","title":"What is a package manager?","text":"<p>A package manager is like an app store for developers, but instead of downloading games or social media apps, it helps them download pieces of code (called packages) that someone else has already written to solve common problems. They can now use this downloaded code to build new stuff upon it.</p> <p>Imagine you're cooking a complex meal. You need salt, pepper, pasta, sauce, etc. Instead of growing tomatoes or grinding flour yourself, you just go to the store and buy what you need.</p> <p>A package manager is that store for developers. It helps them:</p> <ul> <li>Find the ingredients (code libraries) they need.</li> <li>Download and install them quickly.</li> <li>Keep them up to date.</li> <li>Make sure all ingredients work well together (handle compatibility).</li> </ul> <p>Here, we proceed with an example of a package manager named <code>conda</code>. However, the same concepts apply to many other package managers as well. Say, we want to install a package named <code>numpy</code> via the <code>conda</code> package manager. We do this via <code>conda install numpy</code> :</p> <p>The above video shows what happens after we enter the command <code>conda install numpy</code> in a terminal. But, where is the boolean logic involved here? Do you observe the list of other packages populated by <code>conda</code> that it wants to install? These are the packages that are kind of prerequisites for the <code>numpy</code> package to work properly and are called dependencies. A Boolean formula is used to determine this list of packages. Let us explore how the Boolean formula is leveraged here and if the task is as easy as it looks in the video above.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#scenario","title":"Scenario","text":"<p>Say, we want to install a package named <code>Alpha</code> with version <code>2.0</code> (together, we refer to it as <code>Alpha-2.0</code>). The developers of <code>Alpha-2.0</code> specify that their package uses functionalities from the following other packages:</p> <ol> <li>Beta; either of <code>Beta-1.3</code> or <code>Beta-1.4</code> works.</li> <li>Gamma; either of <code>Gamma-0.6</code>  or <code>Gamma-0.7</code> works.</li> </ol> <p>Based on the above specification, we say that <code>Alpha-2.0</code> depends on <code>Beta</code> with version <code>1.3</code> or <code>1.4</code> and on <code>Gamma</code> with version <code>0.6</code> or <code>0.7</code>.</p> <p>However, the developers of <code>Beta</code> specify that their package is also dependent on the functionalities of <code>Gamma</code> in the following manner:</p> <ol> <li><code>Beta-1.3</code> is dependent on <code>Gamma-0.5</code>.</li> <li><code>Beta-1.4</code> is dependent on <code>Gamma-0.6</code>.</li> </ol> Info <p>When we say that <code>alpha-2.0</code> depends on either <code>Beta-1.3</code> or <code>Beta-1.4</code>, it could be that <code>alpha-2.0</code> uses the functionalities common to both <code>Beta-1.3</code> and <code>Beta-1.4</code> and not the ones that are new in <code>Beta-1.4</code>. So, we can either install <code>Beta-1.3</code> or <code>Beta-1.4</code>, but not both at the same time.</p> <p>The above dependencies can be depicted via the diagram shown in Figure 1. To create the graph, we assume each version-specific package is a separate package (for example, we consider <code>Beta-1.3</code> and <code>Beta-1.4</code> as different packages) and represent them as vertices. And we create a directed edge from the package to another version-specific package on which the former depends. </p> <p></p> <p>Figure 1. Dependency graph: A graph depicting the dependencies of the packages. Each box represents a package and each circle inside the box represents a version. We can consider each package and version combination as a different package altogether. Hence, we consider a version-specific package (e.g. Beta-1.4) as a vertex and create a directed edge from the package to another version-specific package on which the former depends on. </p> <p>Now, our objective is to pick the packages and versions to be installed in a way such that:</p> <ol> <li>For each package, only one version is installed to ensure consistency.</li> <li>All dependencies are satisfied.</li> </ol> <p>Given the above conditions, we can observe in Figure 2 that there are two compatible selections of packages:</p> <ol> <li>Alpha-2.0, Beta-1.3 and Gamma-0.6</li> <li>Alpha-2.0, Beta-1.4, and Gamma-0.7</li> </ol> <p></p> <p>Figure 2. Based on our conditions and dependencies, we can have two compatible selections: <code>(i) Alpha-2.0, Beta-1.3 and Gamma-0.6</code>, and <code>(ii) Alpha-2.0, Beta-1.4, Gamma-0.7</code></p> <p>Given the simplicity of the problem in terms of the number of packages and dependencies, we were able to find the selection easily and visually. But how to formally find the selection for a large number of packages and dependencies? And, how does a package manager do it? The answer is Boolean logic. So, let us now find how to transform the problem into a Boolean formula.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#transforming-dependency-requirements-to-logical-formula","title":"Transforming dependency requirements to logical formula","text":"<p>Step 1: We represent each version-specific package as a boolean variable, which can be either <code>True</code> or <code>False</code>. When the variable for the package is <code>True</code>, then the package is picked for installation, and if <code>False</code>, then it is not picked.  For our example, we have 6 different variables as follows: <code>Alpha1.0, Beta1.3, Beta1.4, Gamma0.5, Gamma0.6, and Gamma0.7</code>.</p> <p>Step 2: Each dependency can be represented using implications. For example, if \\(A\\) depends on \\(B\\) then we say, \\(A \\implies B\\) which means that if \\(A\\) is installed then \\(B\\) must be installed and if \\(A\\) need not be installed then it doesn\u2019t matter if \\(B\\) is installed or not. The dependencies in our example can be represented as follows:</p> <ol> <li>\\(Alpha2.0 \\implies (Beta1.3 \\lor Beta1.4)\\)</li> <li>\\(Alpha2.0 \\implies (Gamma0.6 \\lor Gamma0.7)\\)</li> <li>\\(Beta1.3 \\implies (Gamma0.5 \\lor Gamma0.6)\\)</li> <li>\\(Beta1.4 \\implies Gamma0.7\\)</li> </ol> <p>Step 3: To ensure that we have exactly one version of each package, we negate conjunctions of each unordered pair of versions of the same package. Say we have a package <code>A</code> with versions 1 and 2. The boolean formula to ensure a single version would be \\(\\neg (A1 \\land A2)\\), This ensures that \\(A1\\) and \\(A2\\) cannot be simultaneously <code>True</code>. For our example, we have the following conjunctions:</p> <ol> <li>\\(\\neg (Beta1.3 \\land Beta1.4)\\)</li> <li>\\(\\neg (Gamma0.5 \\land Gamma0.6)\\)</li> <li>\\(\\neg (Gamma0.6 \\land Gamma0.7)\\)</li> <li>\\(\\neg (Gamma0.5 \\land Gamma0.7)\\)</li> </ol> <p>Now, if we create a conjunction of all four formulas above, we ensure that no two versions of the package become <code>True</code> or get installed at the same time. The conjunction of the above four terms would look like:</p> \\[ \\neg (Beta1.3 \\land Beta1.4) \\land \\neg (Gamma0.5 \\land Gamma0.6) \\land    \\neg (Gamma0.6 \\land Gamma0.7) \\land  \\neg (Gamma0.5 \\land Gamma0.7) \\] <p>Step 4: Now we create a conjunction of all the terms in <code>Step 1</code>, <code>Step 2</code>, and <code>Step 3</code>, which will result in the following formula:</p> \\[ [Alpha2.0 \\implies (Beta1.3 \\lor Beta1.4)] \\land \\\\ [Alpha2.0 \\implies (Gamma0.6 \\lor Gamma0.7)] \\land \\\\ [Beta1.3 \\implies (Gamma0.5 \\lor Gamma0.6)] \\land \\\\ (Beta1.4 \\implies Gamma0.7) \\land \\\\ \\neg (Beta1.3 \\land Beta1.4) \\land \\neg (Gamma0.5 \\land Gamma0.6) \\land \\\\ \\neg (Gamma0.6 \\land Gamma0.7) \\land  \\neg (Gamma0.5 \\land Gamma0.7) \\] <p>Step 5: The most important point is that <code>Alpha-2.0</code> must be installed. Hence, the variable corresponding to it must always be assigned <code>True</code> i.e \\(Alpha2.0 = True\\). So, we create a conjunction of \\(Alpha2.0\\) with the formula in step 4:</p> \\[ Alpha2.0 \\land [Alpha2.0 \\implies (Beta1.3 \\lor Beta1.4)] \\land \\\\ [Alpha2.0 \\implies (Gamma0.6 \\lor Gamma0.7)] \\land \\\\ [Beta1.3 \\implies (Gamma0.5 \\lor Gamma0.6)] \\land \\\\ (Beta1.4 \\implies Gamma0.7) \\land \\\\ \\neg (Beta1.3 \\land Beta1.4) \\land \\neg (Gamma0.5 \\land Gamma0.6) \\land \\\\ \\neg (Gamma0.6 \\land Gamma0.7) \\land  \\neg (Gamma0.5 \\land Gamma0.7) \\] <p>Now, we just want an assignment of boolean values to each of the variables such that the formula evaluates to <code>True</code>. Packages corresponding to variables with <code>True</code> values will be selected for installation. This problem of finding a possible assignment of values to the Boolean variables such that the formula evaluates to <code>True</code> is called the <code>Functional Boolean Satisfiability (FSAT) Problem</code>. A simple extension/simplification of the problem is to decide if a Boolean formula is satisfiable or not, which is known as the <code>Boolean Satisfiability (SAT) Problem</code>.  If we can find a solution for an instance of the FSAT problem, then we can say that the boolean formula is satisfiable, and if we can\u2019t, we say the formula is unsatisfiable.</p> <p>Before thinking about how to solve the problem, let us first verify if a solution (compatible selection of packages) we found in Figure 2 evaluates to <code>True</code>. Since the formula is quite long, we will evaluate each term of the conjunction separately and then evaluate the final result. For the conjunction to be <code>True</code>, all the terms need to be <code>True</code>; otherwise, the whole formula would evaluate to <code>False</code>.</p> <p>Compatible Selection 1:</p> \\[ \\begin{array}{|c |c |}\\hline Variable &amp; Value \\\\\\hline Alpha2.0    &amp;    True       \\\\Beta1.3     &amp;    True       \\\\Beta1.4     &amp;    False      \\\\Gamma0.5    &amp;    False      \\\\Gamma0.6    &amp;    True       \\\\Gamma0.7    &amp;    False       \\\\\\hline\\end{array} \\] <p>Table 1. Values assigned to each variable as per compatible selection 1</p> \\[ \\begin{array}{|c | c |c |}\\hline\\textbf{Term} &amp; \\textbf{Evaluation} &amp; \\textbf{Result} \\\\\\hline\\text{Alpha2.0} \\implies (\\text{Beta1.3} \\lor \\text{Beta1.4}) &amp; \\text{True} \\implies (\\text{True} \\lor \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Alpha2.0} \\implies (\\text{Gamma0.6} \\lor \\text{Gamma0.7}) &amp; \\text{True} \\implies (\\text{True} \\lor \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Beta1.3} \\implies (\\text{Gamma0.5} \\lor \\text{Gamma0.6}) &amp; \\text{True} \\implies (\\text{False} \\lor \\text{True}) &amp; \\text{True} \\\\\\hline \\text{Beta1.4} \\implies \\text{Gamma0.7} &amp; \\text{False} \\implies \\text{False} &amp; \\text{True} \\\\\\hline \\neg (\\text{Beta1.3} \\land \\text{Beta1.4}) &amp; \\neg (\\text{True} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.5} \\land \\text{Gamma0.6}) &amp; \\neg (\\text{False} \\land \\text{True}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.6} \\land \\text{Gamma0.7}) &amp; \\neg (\\text{True} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.5} \\land \\text{Gamma0.7}) &amp; \\neg (\\text{False} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Alpha2.0} &amp; \\text{True} &amp; \\text{True} \\\\\\hline\\end{array} \\] <p>Table 2. Evaluation of the statement based on compatible selection 1. Since all the terms evaluate to True, the selection is correct.</p> <p>We can observe in Table 2 that all the terms evaluate to <code>True</code>, which means the selection of the packages is indeed correct and satisfies our requirements.</p> <p>An Incompatible Selection:</p> <p>Now, let us try an incompatible selection as visualized in Figure 3, where <code>Gamma-0.5</code> is selected but <code>Alpha-2.0</code> depends on <code>Gamma</code> with versions &gt; 0.5, which is contradictory (note that we can select only one version of each package). Let us see how our Boolean formula detects this.</p> <p></p> <p>Figure 3. An incompatible selection of packages. It is so because we select <code>Gamma-0.5</code> but <code>Alpha-2.0</code> needs <code>Gamma</code> with version &gt; 0.5. As we cannot install multiple versions of the same package, this selection makes it incompatible.</p> \\[ \\begin{array}{|c |c |}\\hline Variable &amp; Value \\\\\\hline Alpha2.0    &amp;    True       \\\\Beta1.3     &amp;    True       \\\\Beta1.4     &amp;    False      \\\\Gamma0.5    &amp;    True      \\\\Gamma0.6    &amp;    False       \\\\Gamma0.7    &amp;    False       \\\\\\hline\\end{array} \\] <p>Table 3. Values assigned to each variable as per the incompatible selection in [Figure 3(#__figure-caption_3)].</p> \\[ \\begin{array}{|c | c |c |}\\hline\\textbf{Term} &amp; \\textbf{Evaluation} &amp; \\textbf{Result} \\\\\\hline\\text{Alpha2.0} \\implies (\\text{Beta1.3} \\lor \\text{Beta1.4}) &amp; \\text{True} \\implies (\\text{True} \\lor \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Alpha2.0} \\implies (\\text{Gamma0.6} \\lor \\text{Gamma0.7}) &amp; \\text{True} \\implies (\\text{False} \\lor \\text{False}) &amp; \\text{False} \\\\\\hline \\text{Beta1.3} \\implies (\\text{Gamma0.5} \\lor \\text{Gamma0.6}) &amp; \\text{True} \\implies (\\text{True} \\lor \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Beta1.4} \\implies \\text{Gamma0.7} &amp; \\text{False} \\implies \\text{False} &amp; \\text{True} \\\\\\hline \\neg (\\text{Beta1.3} \\land \\text{Beta1.4}) &amp; \\neg (\\text{True} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.5} \\land \\text{Gamma0.6}) &amp; \\neg (\\text{True} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.6} \\land \\text{Gamma0.7}) &amp; \\neg (\\text{False} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\neg (\\text{Gamma0.5} \\land \\text{Gamma0.7}) &amp; \\neg (\\text{True} \\land \\text{False}) &amp; \\text{True} \\\\\\hline \\text{Alpha2.0} &amp; \\text{True} &amp; \\text{True} \\\\\\hline\\end{array} \\] <p>Table 4. Evaluation of the statement based on the incompatible selection. Since one term evaluates to False, the whole conjunction will lead to False, and the selection would be marked as incorrect.</p> <p>We can observe in Table 4 that the formula detects the incompatibility described in Figure 3 as the implication \\(Alpha2.0 \\implies (Gamma0.6 \\lor Gamma0.7)\\) becomes <code>False</code> making the whole formula <code>False</code> due to conjunction. The task of the package manager is to avoid such assignments.</p> <p>Now, let us see an unsatisfiable situation that leads to an unsatisfiable instance of the SAT problem.</p> <p>An unsatisfiable situation</p> <p></p> <p>Figure 4. An unsatisfiable situation where <code>Gamma-0.5</code> is already installed in the system as it is a dependency of the already installed package <code>Delta-1.6</code>. This leads to the incompatible selection as described in Figure 3 as the variable for <code>Gamma-0.6</code> will always be set to <code>True</code>.</p> <p>As visualized in Figure 4, let us assume that some package named <code>Delta-1.6</code>, which depends on <code>Gamma-0.5</code>, is already installed in our system, and we now need to install <code>Alpha-2.0</code>. Since <code>Delta-1.6</code> depends on <code>Gamma-0.5</code> , \\(Gamma0.5\\) will always be <code>True</code>. This will lead to the same situation as shown in Figure 3, making this instance of the problem unsatisfiable. In such cases, the package manager would ask the user to upgrade <code>Delta-1.6</code> to <code>Delta-1.7</code>. If users upgrade <code>Delta</code>, then <code>Gamma-0.5</code> would be upgraded to <code>Gamma-0.6</code>. This will make the problem satisfiable with the solution same as the 1st compatible selection shown in Figure 2.</p> <p>When the <code>conda</code> package manager finds such feasible options, it would prompt the user for such an upgrade, as shown in Figure 5. </p> <p></p> <p>Figure 5. A representative example where <code>conda</code> package manager prompts user if it is fine to upgrade <code>delta</code> and <code>gamma</code> in order to install <code>alpha-2.0</code>.</p> <p>When there is no option for upgrading/downgrading in an unsatisfiable situation, package manager would raise error stating that the requirements are not satisfiable. Check Figure 6 for an example of such a situation with the <code>conda package manager</code>.</p> <p></p> <p>Figure 6.<code>Conda</code> raising an unsatifiable error as it finds an unsatisfiable conditions. Th user tries to install <code>numpy-1.15.4</code> which depends on <code>python</code> with versions <code>&gt;=2.7,&lt;2.8.0a0</code>, <code>&gt;=3.6,&lt;3.7.0a0</code>, and <code>python &gt;=3.7,&lt;3.8.0a0</code>. However, another dependency of <code>numpy</code> is <code>pin-1</code> depends on <code>python-3.10</code> which conflicts with the previously reported requirements of <code>python</code>.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#regarding-solving-the-sat-problem","title":"Regarding solving the SAT problem","text":"<p>Before discussing solving the SAT problem, first let us discuss verifying if a given solution satisfies the Boolean formula. In the previous section, we verified multiple assignments of boolean variables to check if they satisfy the boolean formula. It can be observed that the number of computations needed to verify the assignment is proportional to the number of operators in it, which is similar to the number of literals in the formula. (NOTE: A literal is some boolean variable \\(x_i\\) or its negation \\(\\neg x_i\\)). </p> <p>If we express the time taken to verify the boolean formula with \\(n\\) literals as the number of computation performed, then the time to verify a SAT formula would be some linear function of \\(n\\), which would be a polynomial (as we need to iterate though the operands and replace it with result of the operands until we get the final result). We can think of a sequence of operations that can be performed in polynomial time as a fast algorithm (let us refer to the sequence of operations as an algorithm). Such problems are considered to be a part of a class of problems named <code>p</code>. So, verification of a Boolean formula given an assignment comes under the <code>p</code> class of problems.</p> <p>Now, let us discuss how to find an assignment of the variables. The most naive way would be to try all possible assignments. But this would be exponential in terms of the number of variables. The larger the number of variables, the longer it takes to find an assignment. But, do we have an algorithm that can find an assignment in polynomial time instead of exponential time? Interestingly, the current experience of mathematicians is that there is no such algorithm. However, there exist implementations of heuristic SAT solvers that can find satisfying assignments in a reasonable time, and tons of research is done in developing such algorithms. Discussion of those algorithms is out of the scope of this blog due to my limited knowledge in that area. But, the good news is we can use those implementations to solve our problem of selecting the appropriate dependencies. In addition to this, the implementations also provide recommendations to make the problem satisfiable if it is not, as seen in the situation described in Figure 4. For example, <code>conda</code> uses some implementations like <code>PicoSAT</code> and <code>libsolv</code>. If you are comfortable in Python, you may check PySAT, which provides an implementation of SAT solvers in Python.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#how-difficult-is-the-sat-problem","title":"How difficult is the SAT problem?","text":"What is reduction? <p>If we can transform one problem <code>A</code> into another problem <code>B</code> in polynomial time, we say that problem <code>A</code> is reduced to problem <code>B</code>. If we find a polynomial time algorithm for <code>B</code>, we will have a polynomial time algorithm for <code>A</code> too by first transforming <code>A</code> to <code>B</code> and then solving for <code>B</code>. For example, our problem of finding the correct selection of packages has been transformed into a SAT problem in polynomial time. We just had to write boolean formulas for each condition, and doing so is equivalent to doing tasks with a number of operations as some constant times the number of conditions, which would be linear in the number of conditions.</p> <p>As of now, we don\u2019t have a polynomial time algorithm for solving the SAT problem, but we saw that given a solution, the verification can be done in polynomial time, and such problems with polynomial time verification are said to be in the class named <code>np</code>. An interesting fact about the SAT problem is that any other problem in <code>np</code> can be reduced to SAT in polynomial time. One such example is our problem of selecting appropriate packages that satisfy all dependencies. That means if we have a polynomial time algorithm to solve SAT, then we have a polynomial time algorithm for all other problems in <code>np</code>. Mathematicians believe that there is no such algorithm, and nobody has been able to prove this yet. But if one can find such an algorithm, then not only will installing a package become fast, but it will also lead to crazy consequences. Check this video by Polylog for more information on this.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#game-time","title":"Game time !!!","text":"Note <p>The game here is provided as a supplementary for better understanding and hands-on example. The game was developed with the help of AI tools (GitHub Copilot, Replit, Cursor).</p> <p>Want to try your hands at solving the SAT problem for dependency resolution? Check the following game for more hands-on examples. Check how boolean logic can help in finding constraints.</p> <p>Game: Package Dependency Resolution Game</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#other-applications-of-boolean-propositional-logic","title":"Other Applications of Boolean Propositional Logic","text":"<p>There are many other applications of boolean formulas where constraints can be expressed as boolean formula. We list a couple of them below.</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#access-control-policies","title":"Access Control Policies","text":"<p>Can be used to define and enforce access rules in computer systems based on roles, permissions, and environmental conditions.</p> <p>Examples:</p> <ul> <li> <p>Grant access if the user is an admin or has read permission:   $ (\\text{Admin} \\lor \\text{ReadPermission}) \\implies \\text{Access}$</p> </li> <li> <p>Deny access during lockdown:   $ \\text{Lockdown} \\implies \\neg \\text{ Access }$</p> </li> <li> <p>A guest and admin role cannot be assigned together:   $ \\neg (\\text{ Guest } \\land \\text{ Admin })$</p> </li> </ul>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#course-prerequisites-and-scheduling","title":"Course Prerequisites and Scheduling","text":"<p>Can be used in academic planning tools to ensure students meet course prerequisites and avoid scheduling conflicts.</p> <p>Examples:</p> <ul> <li> <p>Taking CS201 requires completing CS101:   $ \\text{CS201} \\implies \\text{CS101}$</p> </li> <li> <p>Prevent scheduling overlap between Bio101 and Chem101:   $ \\neg  (\\text{Bio101} \\land \\text{Chem101})$</p> </li> <li> <p>Choose only one from three electives:   $ (\\text{E1} \\lor \\text{E2} \\lor \\text{E3}) \\land \\neg (\\text{E1} \\land \\text{E2}) \\land \\neg (\\text{E1} \\land \\text{E3}) \\land \\neg (\\text{E2} \\land \\text{E3})$</p> </li> </ul>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#resource-management-by-operating-systems","title":"Resource Management by Operating Systems","text":"<p>Can be used to manage allocation of resources like CPU, memory, and Input/Output (I/O) devices in a computer system without conflicts or deadlocks.</p> <p>Examples:</p> <ul> <li> <p>A process can run only if it has both CPU and memory available:   $ (\\text{HasCPU} \\land \\text{HasMemory}) \\implies \\text{CanRun}$</p> </li> <li> <p>Two processes cannot write to the same file simultaneously:   $ \\neg (\\text{Write(P1, FileX)} \\land \\text{Write(P2, FileX)})$   Here, \\(P1\\) and \\(P2\\) are two processes or software running in a computer system, and \\(FileX\\) is a file.</p> </li> <li> <p>Deadlock detection rules:</p> <p>Imagine a system with:</p> <ul> <li>Two processes: P1 and P2</li> <li>Two resources: R1 and R2</li> </ul> <p>Scenario:</p> <ul> <li>P1 holds R1 and is waiting for R2. P1 will never reach to completion if it doesn't get R2.</li> <li>P2 holds R2 and is waiting for R1. P2 will never reach to completion if it doesn't get R1.</li> </ul> <p>This creates a circular wait, which is one of the conditions for deadlock. Let\u2019s define Boolean variables:</p> <ul> <li>Hold(Pi, Rj) would be True if Pi holds Rj for some usage</li> <li>Wait(Pi, Rj) would be True if Pi is waiting for Rj to be released by some other process</li> </ul> </li> </ul> <p>Now the following formula can be used to detect potential deadlocks:   $ (\\text{Hold}(P1, R1) \\land \\text{Wait}(P1, R2) \\land \\text{Hold}(P2, R2) \\land \\text{Wait}(P2, R1) ) \\implies \\text{Deadlock}$</p>"},{"location":"blog/2025/06/12/satisfying-installs-how-boolean-logic-navigates-software-dependencies/#references","title":"References","text":"<ol> <li>Dependency Resolution Made Simple</li> <li>The Magic of Dependency Resolution</li> <li>Version SAT</li> <li>Deep Dive into Conda Install</li> <li>Deep dive: solvers</li> <li>LibMamba vs Classic</li> <li>What P vs NP is actually about</li> </ol>"},{"location":"blog/2023/05/30/preprocess-custom-text-dataset-using-torchtext-octicons-link-external-16/","title":"Preprocess custom text dataset using Torchtext","text":"<p>This tutorial illustrates the use of torchtext (A PyTorch library) to pre-process a dataset that is not built-in. This article is available at PyTorch.</p> <p>Redirecting to PyTorch</p>"},{"location":"blog/category/propositional-logic/","title":"Propositional Logic","text":""},{"location":"blog/category/software-development/","title":"Software Development","text":""},{"location":"blog/category/nlp/","title":"NLP","text":""},{"location":"blog/category/machine-learning/","title":"Machine Learning","text":""}]}